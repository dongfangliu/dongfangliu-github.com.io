<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Unity札记-FlappyBird原理及改良计划]]></title>
      <url>%2F2017%2F02%2F08%2FUnity%E6%9C%AD%E8%AE%B0-FlappyBird%E5%8E%9F%E7%90%86%E5%8F%8A%E6%94%B9%E8%89%AF%E8%AE%A1%E5%88%92%2F</url>
      <content type="text"><![CDATA[FlappyBird原型思路及图示 人物不动，背景移动 生成新的障碍物并使其移动 通过碰撞检测来更新分数和存活情况 FlappyBird改良01 低于地面的障碍物设置为不可见 通过障碍物的空间由 确定–&gt;随机 FlappyBird改良02 增加游戏难度 gamelevel 通过计时判断来改变游戏难度，每60s提高游戏难度(gamelevel+1) 游戏难度变化影响 生成柱子的数目和速率\水平飞行速度 FlappyBird改良03 增加技能果实和物品漕，通过获取技能果实，点击物品使用技能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Unity札记-FlappyBird知识要点]]></title>
      <url>%2F2017%2F02%2F08%2FUnity%E6%9C%AD%E8%AE%B0-FlappyBird%2F</url>
      <content type="text"><![CDATA[终于换了新电脑啦，开始独立游戏开发之路！使用的引擎是Unity3D,上个暑假正好有涉猎，上手几乎没什么难度。 打算仿制的第一个游戏就是FlappyBird,2D经典游戏，有着高中时的回忆hhhhh。这篇博客主要用于整理一些Unity的小小知识点。 知识要点1. Sorting LayerSorting layer 是一个渲染层，在Unity中可以自定义创建多个渲染层级，层级越往下，越后渲染。通过为各个对象设置渲染层，可以控制它们的覆盖关系。2. SpritesSprites 是多个Texture的集合体，也就是一组图片，常常在2D游戏中作为一个对象来处理，因为我们需要很多动作，这些动作利用Texture结合Animation+Animator生成.3. Animation+Animator Animation 动画生成器具体使用方法参见 https://unity3d.com/learn/tutorials/topics/animation Animator 动画调配器具体使用方法参见 https://docs.unity3d.com/Manual/class-AnimatorController.html 4. UI canvas所有的UI都依赖于画布上，也就是Canvas.5. Singleton Pattern单例模式最初的定义出现于《设计模式》（艾迪生维斯理, 1994）：“保证一个类仅有一个实例，并提供一个访问它的全局访问点。”Java中的示例代码12345678910111213 public class SingletonClass&#123; private static volatile SingletonClass instance=null; public static SingletonClass getInstance()&#123; synchronized(SingletonClass.class)&#123; if(instance==null)&#123; instance=new SingletonClass(); &#125; &#125; return instance; &#125; private SingletonClass()&#123;&#125;&#125; 在FlappyBird中的应用： 设置有且只有一个GameController对象,避免重复多个对象导致游戏机制混乱。具体代码代码如下：#1 6. 如何重载场景、动态由Prefab创建对象instantiate()具体使用方法参见 https://docs.unity3d.com/ScriptReference/Object.Instantiate.html 7. 获取子物体的快捷方法gameobject.transform.Find(&quot;name&quot;).GameObject; 具体使用方法参见https://docs.unity3d.com/ScriptReference/Transform.Find.html 8. LocalPositon,Postion及相关转化方法LocalPosition,position的区别 position是根据世界原点为中心 localPosition是根据父节点为中心,如果没有父节点,localpositon和position是没有区别的 选中一个物体左上角Global和Local切换看物体世界坐标轴和本地坐标轴 9. 世界坐标,屏幕坐标,视口坐标之间的转换坐标介绍 World Space（世界坐标）：我们在场景中添加物体（如：Cube），他们都是以世界坐标显示在场景中的。transform.position可以获得该位置坐标。 Screen Space（屏幕坐标）:以像素来定义的，以屏幕的左下角为（0，0）点，右上角为（Screen.width，Screen.height），Z的位置是以相机的世界单位来衡量的。注：鼠标位置坐标属于屏幕坐标，Input.mousePosition可以获得该位置坐标，手指触摸屏幕也为屏幕坐标，Input.GetTouch(0).position可以获得单个手指触摸屏幕坐标。 ViewPort Space（视口坐标）:视口坐标是标准的和相对于相机的。相机的左下角为（0，0）点，右上角为（1，1）点，Z的位置是以相机的世界单位来衡量的。 坐标转换世界坐标→屏幕坐标： camera.WorldToScreenPoint(transform.position);这样可以将世界坐标转换为屏幕坐标.其中camera为场景中的camera对象。 屏幕坐标→视口坐标： camera.ScreenToViewportPoint(Input.GetTouch(0).position);这样可以将屏幕坐标转换为视口坐标。其中camera为场景中的camera对象。 视口坐标→屏幕坐标： camera.ViewportToScreenPoint();视口坐标→世界坐标： camera.ViewportToWorldPoint();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[班车时刻表相关源码]]></title>
      <url>%2F2017%2F01%2F22%2F%E7%8F%AD%E8%BD%A6%E6%97%B6%E5%88%BB%E8%A1%A8%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%2F</url>
      <content type="text"><![CDATA[喜欢用自己的博客记录一下自己的道路。反正也没什么人看，我就可以自HIGH了～这篇博客主要还是记录和解释一下班车时刻表的js/c++代码,还有相关css样式的设置。----一个菜鸡的自我救赎道路 辅助c++代码我写了一个c++程序主要是有两个用途 接收输入数据生成md表格制式 将输入的时间数据（例如18：20）切分为两部分,小时和分钟并生成对应的js变量声明语句。第二个是基于第一个实现的，即接受数据之后针对特定的时间数据切分声明变量。（……你是有多懒……） 作为一个自己用的小程序，我并没有对输入的数据是否为时间数据进行判断，能实现功能就行啦～～ po代码main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;class stringlist&#123; //一个存储string类型数据的链表 stringlist * head = nullptr;public: void add_next(string s);//添加下一个节点 string pop(); //从头部开始pop数据 stringlist(string s):ele(s)&#123;head =this;&#125;//含参构造器 stringlist()&#123;head= this;&#125; //默认构造器 string ele=""; //当前节点的数据 stringlist * next= nullptr; //指向下一个节点的指针&#125;;string fixzero(string basic_string);void stringlist::add_next(string s) &#123; stringlist *insert_pos = this; if (insert_pos-&gt;ele == "") &#123;//当前节点元素未赋值 ele = s; &#125; else&#123; // 已有值 while(insert_pos-&gt;next!= nullptr)&#123; //依次找到一个空的节点 insert_pos = insert_pos-&gt;next; &#125; insert_pos-&gt;next = new stringlist(s);//添加新节点 &#125;&#125;string stringlist::pop() &#123; if(head== nullptr)&#123; //当前节点可能不存在 return ""; //返回空字符串 &#125;else&#123; string pop = head-&gt;ele; //弹出当前节点的数据 head = head-&gt;next; //跳到下一个节点 return pop; //返回数据 &#125;&#125;void list_test()&#123; //测试stringlist的函数 string teststr[] = &#123;"1","2","3","4","5","6","7"&#125;; stringlist stringlist1 = stringlist(); for(int i = 0 ; i &lt; 7;i++)&#123; stringlist1.add_next(teststr[i]); &#125; while(true)&#123; cout&lt;&lt;stringlist1.pop()&lt;&lt;endl; &#125;&#125;void split_two(stringlist * list ,int num ,string car )&#123; //一个切分时间的函数 （数据链表，数据数量，输出标识） ofstream output("/root/ClionProjects/md_helper/"+car+"_timelist"); //声明一个文件输出流用于输出js变量声明代码 for(int i =0 ; i&lt;num;i++) &#123; stringlist *temp = (list+i); //输入数据 stringlist hourlist = stringlist(); stringlist minutelist = stringlist(); while (temp != nullptr //数据有效) &#123; string a = temp-&gt;ele.substr(0, 2); //截取前两位 小时 hourlist.add_next(a); string b = temp-&gt;ele.substr(3, 5);//截取最后两位 分钟 minutelist.add_next(b); temp = temp-&gt;next; //进入下一数据 &#125; string out; output&lt;&lt;"var hour"&lt;&lt;i&lt;&lt;" = "; //输出这一组时间数据的小时数，以逗号分隔 output &lt;&lt; "["; while ((out = hourlist.pop()) != "") &#123; output &lt;&lt; out &lt;&lt; ','; &#125; output &lt;&lt; "];" &lt;&lt; endl; output&lt;&lt;"var min"&lt;&lt;i&lt;&lt;" = "; //输出这一组数据的分钟数，以逗号分隔 output &lt;&lt; "["; while ((out = minutelist.pop()) != "") &#123; output &lt;&lt; out &lt;&lt; ','; &#125; output &lt;&lt; "];" &lt;&lt; endl; &#125; output.close(); //关闭输出流&#125;int main() &#123; cout&lt;&lt;"Please enter the number of columns"&lt;&lt;endl; int num=0; cin&gt;&gt;num; //输入应生成多少列 cout&lt;&lt;"请输入班车信息"&lt;&lt;endl; string car; cin&gt;&gt;car; //输入班车信息 stringlist table[num]=&#123;&#125;;//建立链表数组已存储各个列的数据 string format[3]=&#123;"-------------",":-------------:","------------:"&#125;; for(int i = 0 ; i &lt; num ;i++) &#123; std::cout &lt;&lt; "Enter col " &lt;&lt; i &lt;&lt;"'s title"&lt;&lt; std::endl; string s = ""; int forma = 0; cin&gt;&gt;s;//输入第i列的标题 table[i].add_next(s); std::cout &lt;&lt; "Enter col " &lt;&lt; i &lt;&lt;"'s format (left-align 0 ,center 1 ,right-align 2)"&lt;&lt; std::endl; cin&gt;&gt;forma;//输入第i列的对齐方式 table[i].add_next(format[forma%3]); std::cout &lt;&lt; "Enter col " &lt;&lt; i &lt;&lt;"'s data \n1 data/line \n ended by a / "&lt;&lt; std::endl;//输入第i列的数据，以/结束 while (true) &#123; cin &gt;&gt; s; if (s == "/") &#123; break; &#125; else &#123; table[i].add_next(/*fixzero(*/s/*)*/);//添加时间数据 &#125; &#125; &#125;// for(int i = 0 ;i &lt;num;i++)&#123;// split_two(table,num,car); //只能切分时间数据，请按需要启用// &#125; string data[num]=&#123;&#125;;//一个数组用于存储当前行的表格数据 bool nodata = true; string output = ""; for(int i = 0 ; i &lt; num ;i=(i+1)%num) &#123;//逐行输出表格 data[i]= table[i].pop(); nodata = nodata&amp;&amp;(data[i]==""); output+=("|"+data[i]); if(i+1 == num) &#123; if(!nodata)&#123; cout&lt;&lt;output&lt;&lt;"|"&lt;&lt;endl; output=""; nodata =true; &#125;else&#123; break; &#125; &#125; &#125; exit(0);&#125;string fixzero(string basic_string) &#123;//修正时间数据的长度到xx:xx 5个字符长度，方便切分数据 while(basic_string.length()&lt;5)&#123; basic_string="0"+basic_string; &#125; return basic_string;&#125; 总结一下，这些代码的作用就是对输入的数据生成需要的md表格制式文本也可以按列输入时间数据，12：30，切分生成js代码到指定目录下。12345678910...var hour2 = [06,07,08,09,10,11,12,13,14,15,15,16,17,17,18,19,];//第2列的小时数据var min2 = [55,50,40,20,00,00,00,00,00,00,40,20,00,40,20,00,];//第2列的分钟数据var hour3 = [07,08,09,09,10,11,12,13,14,15,16,16,17,18,18,19,];//第3列的小时数据var min3 = [15,10,00,40,20,20,20,20,20,20,00,40,20,01,40,20,];//第3列的分钟数据... js代码 输入数据：输入班车时刻表，生成的js时间变量声明代码 目的：计算距离下一个班车的时间并部署到网页上 po代码showtime.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104var hour0 = [06,07,07,08,08,08,09,09,10,11,12,13,14,15,15,15,16,16,16,17,17,17,18,18,18,19]; //学校-地铁站1 工作日var min0 = [55,20,40,00,20,40,00,20,00,00,00,00,00,00,20,40,00,20,40,00,20,40,01,20,40,00]; var hour1 = [07,07,08,08,08,09,09,09,10,11,12,13,14,15,15,16,16,16,17,17,17,18,18,18,19,19];//地铁站1-学校 工作日var min1 = [15,40,00,20,40,00,20,40,20,20,20,20,20,20,40,00,20,40,00,20,40,01,21,40,00,20];var hour2 = [06,07,08,09,10,11,12,13,14,15,15,16,17,17,18,19];//学校-地铁站1 节假日var min2 = [55,50,40,20,00,00,00,00,00,00,40,20,00,40,20,00];var hour3 = [07,08,09,09,10,11,12,13,14,15,16,16,17,18,18,19];//地铁站1-学校 节假日var min3 = [15,10,00,40,20,20,20,20,20,20,00,40,20,01,40,20];var hour4 = [09,10,11,12,13,14,15,16,17,17,18,19,];//学校-地铁站2 工作日var min4 = [25,25,05,25,25,25,25,25,15,45,45,40,];var hour5 = [07,07,08,09,10,11,12,13,14,15,];//地铁站2-学校 工作日var min5 = [30,40,30,45,45,25,45,45,45,45,];var hour6 = [09,11,17,17,];//学校-地铁站2 节假日var min6 = [15,00,00,30,];var hour7 = [08,09,11,];//地铁站2-学校 节假日var min7 = [30,30,15,];//针对我的班车时刻表来说，有四列，学校-地铁站1,地铁站1-学校，学校-地铁站2，地铁站2-学校，其中又有工作日和节假日两个表，于是就是8组数据var HourList = [hour0,hour1,hour2,hour3,hour4,hour5,hour6,hour7];//小时数据整合到HOURLIST里var MinList = [min0,min1,min2,min3,min4,min5,min6,min7];//分钟数据整合到MinLIST里function get_static_Dates(hourlist ,minlist,curr_date) &#123; //按照输入的班车时刻表，即HOURLIST，MINLIST生成当日的时刻表，存储到Dates类型数据 var Dates = new Array(hourlist.length); for(var i = 0 ; i &lt;hourlist.length ;i++)&#123; Dates[i] = new Array(hourlist[i].length); for(var j =0 ; j&lt;hourlist[i].length;j++)&#123; Dates[i][j]=new Date(curr_date.getUTCFullYear(),curr_date.getUTCMonth(),curr_date.getDate(),hourlist[i][j],minlist[i][j],0); &#125; &#125; return Dates; //完成Dates二重数组的建立，行（哪班车）-列（第几班车）&#125;function get_diff_time(Dates,curr_date) &#123; // 计算当前时间与班车时间各班次的时间差//以下需要持续刷新并部署到网页上 var differ_time_put = new Array(Dates.length); // 存储时间差的数组，因为有好几个班次的数据都需要计算 for(var a = 0 ; a &lt;Dates.length ;a++)&#123; //遍历班次 for(var b=0 ; b&lt;Dates[a].length;b++)&#123; //遍历该班次的各个班车时间 var data = Dates[a][b].getTime() - curr_date.getTime(); //计算与当前班次当前班车时间的时间差 ，当前时间距1970的毫秒数-班车时间距1970年毫秒数 if(data &gt; 0)&#123; //此刻尚有班车可等 var leave1=data%(24*3600*1000); var hour = Math.floor(leave1/(3600*1000)); var leave2 = leave1%(3600*1000); var minute = Math.floor(leave2/(60*1000)); var leave3 = leave2%(60*1000); var second = Math.round(leave3/1000); differ_time_put[a] = [hour, minute, second]; //算出时间差&#123;小时、分钟、秒&#125; 并存储起来 break; &#125;else&#123; //此刻无班车可等 if(b ==Dates[a].length-1)&#123; //当前班次已停运了，最后一个班车时间都错过了 differ_time_put[a] = "已停运."; &#125; &#125; &#125; &#125; return differ_time_put;&#125;function update_times() &#123; var curr_date = new Date(); var static_dates = get_static_Dates(HourList,MinList,curr_date); // 这一天的标准时刻表 var diff_time = get_diff_time(static_dates, curr_date); var display_time = new Array(diff_time.length/2); //需要部署的时间差数据，因为工作日节假日的数据都计算了，但是今天只能是两者之一 if(curr_date.getDay()&lt;6 &amp;&amp; curr_date.getDay()&gt;0)&#123; //工作日 display_time = [diff_time[0],diff_time[1],diff_time[4],diff_time[5]]; &#125;else&#123;//节假日，简化判断为周末 display_time = [diff_time[2],diff_time[3],diff_time[6],diff_time[7]]; &#125; for (var i = 0; i &lt; display_time.length; i++) &#123; var id = "content" + i; //部署标签 var elem = document.getElementById(id); //通过标签找对象 if (typeof elem !== 'undefined' &amp;&amp; elem !== null) &#123;//对象已渲染成功，存在 var output;//输出的内容 if (display_time[i].length == 3) &#123;//班车未停运 if (display_time[i][0] != 0) &#123; //输出内容 为 小时：分钟：秒钟 output = display_time[i][0] + ":" + display_time[i][1] + ":" + display_time[i][2]; &#125; else &#123; //输出内容 为 分钟：秒钟 output = display_time[i][1] + ":" + display_time[i][2]; &#125; &#125; else &#123;//班车已停运 output = display_time[i]; &#125; document.getElementById(id).innerHTML = output;//设置对象的数据。 &#125; &#125;&#125;function setTimetitles() &#123; //部署班车信息到html标签上 var hints= ["学校-金科路","金科路-学校","学校-张江","张江-学校"]; var setted = ""; for (var i = 0; i &lt; hints.length; i++) &#123; var id = "title" + i; var elem = document.getElementById(id); if(typeof elem !== 'undefined' &amp;&amp; elem !== null) &#123; document.getElementById(id).innerHTML= hints[i]; setted+="1"; &#125;else&#123; setted+="0"; &#125; &#125; if(setted!="1111")&#123;//某个标签未设置好 setTimeout(setTimetitles(),200); //继续尝试设置 &#125;&#125;setTimetitles();//部署班车信息setInterval(update_times,500);//每0.5s更新一次班车信息 css样式与HTML标签编辑css样式table.css123456789101112131415161718192021222324252627282930.showtime_title&#123; padding-top: 3px; border-top-left-radius: 5px; border-top-right-radius: 5px; font-family: &quot;Microsoft YaHei&quot;,微软雅黑,sans-serif; font-size: large; color:#ffffff; background:#4876FF; height:30px; width: 102px; text-align: center;&#125;.showtime_content&#123; padding-top: 8px; border-style:solid outset; border-color: #6d9bb4; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; font-family: &quot;Microsoft YaHei&quot;,微软雅黑,sans-serif; font-size: x-large; background:#ffffff; color:#4876FF; height:52px; width: 96px; text-align: center;&#125;.display_inline&#123; display: inline-block; margin: 20px 20px 20px 20px;&#125; html标签table.html1234567891011121314151617&lt;div class = display_inline&gt; &lt;div class=&quot;showtime_title&quot; id=&quot;title0&quot;&gt;学校-金科路&lt;/div&gt; &lt;div class=&quot;showtime_content&quot; id = &quot;content0&quot;&gt;12:29&lt;/div&gt;&lt;/div&gt;&lt;div class = display_inline&gt; &lt;div class=&quot;showtime_title&quot; id=&quot;title1&quot;&gt;学校-金科路&lt;/div&gt; &lt;div class=&quot;showtime_content&quot; id = &quot;content1&quot;&gt;12:29&lt;/div&gt;&lt;/div&gt;&lt;div class = display_inline&gt; &lt;div class=&quot;showtime_title&quot; id=&quot;title2&quot;&gt;学校-金科路&lt;/div&gt; &lt;div class=&quot;showtime_content&quot; id = &quot;content2&quot;&gt;12:29&lt;/div&gt;&lt;/div&gt;&lt;div class = display_inline&gt; &lt;div class=&quot;showtime_title&quot; id=&quot;title3&quot;&gt;学校-金科路&lt;/div&gt; &lt;div class=&quot;showtime_content&quot; id = &quot;content3&quot;&gt;12:29&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src =show_time.js&gt;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown表格生成器]]></title>
      <url>%2F2017%2F01%2F22%2Fmarkdown%E8%A1%A8%E6%A0%BC%E7%94%9F%E6%88%90%E5%99%A8-1%2F</url>
      <content type="text"><![CDATA[前段时间为了写那个班车表的md文件，手工写md表格的时候一直感觉很容易弄错，想着如果自己有一个程序能乖乖地按输入内容和要求生成md的表格制式就好啦。于是就写了一个简单的小程序。 附上源码链接md_column_builder README.md This is a small c++ project which aims at helping build tables in markdown format in a visual and handy way. Environment Linux or Mac How to useUnder the project location $ make This will create a md_col_builder executable Please add the executable permission $ chmod +x md_col_builder executable Now you can use it without arguments.And this is the only way to use it. $ ./md_col_builder I provided a SampleInput and Sample output. Hope it to be helpful! If you want it to output into a file,Please use “ -o filename “ as follows: $ ./md_col_builder -o myout That’s All. Thx!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何在hexo中插入css与js]]></title>
      <url>%2F2017%2F01%2F12%2F%E5%A6%82%E4%BD%95%E5%9C%A8hexo%E4%B8%AD%E6%8F%92%E5%85%A5css%E4%B8%8Ejs%2F</url>
      <content type="text"><![CDATA[前记 这一周刚刚开始用HEXO做博客，学着用了markdown。前两天弄了一个学校的班车时刻表，就是用markdown写一个表格，一列有很多很多的时间数据，打着打着就头晕了……于是小东花了一点时间，写了一个md表格制式生成器，这两天整理完再发到github。那表格有了，我又想实现一个漂亮的计时的功能（代码就换下一篇再说）只好去琢磨怎么再hexo中插入css和js文件，于是就有了这篇博文。 关于markdown markdown是什么？ markdown和html标签 hexo中的md语法应用 md是什么？markdown首先是一种语法。它提供了很多的标记符号（例如#,*,&gt;等等），赋予这些符号功能性含义(比如标题，引用……），只要把这些符号有序地写入，就能交由解析程序生成想要的html标签式的网页文章。 举个例子（引用）书写 &gt; 我是一条大大的咸鱼，深深地埋在罐头之中～ 效果 我是一条大大的咸鱼，深深地埋在罐头之中～ markdown和html标签 HTML 的区段（行内）标签如 &lt;span&gt; 、 &lt;cite&gt; 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用HTML标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt; 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 也就是说，md语法和html标签兼容，因为md本身经过解析后就会成为html制式。于是我们在hexo插入js代码和css样式看到了希望。 hexo中的md语法应用纯md#### 关于markdown //四级标题 &gt; 1. ###### markdown是什么？ //六级标题 &gt; 2. ###### markdown和html标签 &gt; 3. ###### hexo中的md语法应用 md+html&gt; 第一行&lt;br&gt;第二行 效果 第一行第二行 如何插入css呢？ 打开 _themes/(主题名)/source/css_ 比如我的就是 themes/next/source/css 创建一个文件夹存放自己的css themes/next/source/css/_my 打开 themes/next/source/css/main.styl 添加 @import &quot;_my/我的css.css&quot;; 这样，在加载网页的时候主题文件加载时就会顺便把我们的css载入进去。 Note:自己的css不要和主题的css重名。 如何插入js呢？ 希望本菜鸟能给其他菜鸟简洁有力的帮助。根据我昨晚的4个小时的搜索，网络上其实是没有现行的方法来解决这一问题的。 不用尝试去看什么hexo官方的辅助函数用法了。那是添加到文章模板里面的，除非你想每篇文章都启用一个js. 在source 中加入的自定义的文件和文件夹, hexo g 之后都会在 public 文件夹中生成对应的文件及文件夹。 我的方法即是利用第二点，经过小东两个多小时的血汗测试。得出以下结论： 所有原生的文件夹比如 images , js/src 等等在经过 hexo d 之后,通过域名访问都只能访问该目录下单个文件，不能访问其子文件夹，也就是自定义的文件夹在上传到github之后不能通过网址直接打开。创建子文件夹存放代码的方案，废了。 存放在 source 等直接目录下的js代码，经过 hexo g 之后都会在某些部分出现乱码，所以这一方案也废了。也许可以写一个程序，比如在代码里面加一些斜杠，使generate过程中不翻译为乱码。 放在 public 文件夹中的文件都（默认为加载好的）会上传到github上用来部署网页。 所以，我的方案是 代码直接放在public/images/下，不放再source/images/下 对应 博客.md中 加入 &lt;script&gt; src 指向 /images/my_code.js hexo ghexo d 这样就大功告成，本地上和网络上js代码都能成功跑起来！ 穷人只能瞎折腾，有钱不如买主机。 _config.yml目录下有一个code_dir,可以设置代码存放位置,经过我设置到js/src/_my,用官方的inclued_code标签并没有什么用处。官方在这里的使用也没有清楚说明，弄清楚的朋友请留言告知！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[班车时刻表]]></title>
      <url>%2F2017%2F01%2F12%2F%E7%8F%AD%E8%BD%A6%E6%97%B6%E5%88%BB%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[班车时刻表 学校-金科路12:29学校-金科路12:29学校-金科路12:29学校-金科路12:29 工作日(去) 工作日(返) 节假日（去） 节假日（返） 6:55 7:15 6:55 7:15 7:20 7:40 7:50 8:10 7:40 8:00 8:40 9:00 8:00 8:20 9:20 9:40 8:20 8:40 10:00 10:20 8:40 9:00 11:00 11:20 9:00 9:20 12:00 12:20 9:20 9:40 13:00 13:20 10:00 10:20 14:00 14:20 11:00 11:20 15:00 15:20 12:00 12:20 15:40 16:00 13:00 13:20 16:20 16:40 14:00 14:20 17:00 17:20 15:00 15:20 17:40 18:01 15:20 15:40 18:20 18:40 15:40 16:00 19:00 19:20 16:00 16:20 16:20 16:40 16:40 17:00 17:00 17:20 17:20 17:40 17:40 18:01 18:01 18:21 18:20 18:40 18:40 19:00 19:00 19:20 校内班车 工作日(去) 工作日(返) 节假日（去） 节假日（返） 7:30 （地铁站发车,随到即开,预计20分钟） 7:30 9:15 8:30 7:40（同上） 7:40 11:00 9:30 8:30（同上） 8:30 17:00 11:15 9:25 9:45 17:30 19:30（周日-金科路，发车） 10:25 10:45 20:30（同上） 11:05 11:25 21:30（同上） 12:25 12:45 13:25 13:45 14:25 14:45 15:25 15:45 16:25 16:25（环科路发车，随到即开，预计20分钟） 17:15 17:15（同上） 17:45 17:45（同上） 18:45 18:45（同上） 19:40 19:45（同上） data from zhouzean.tk/bus]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小记16]]></title>
      <url>%2F2016%2F12%2F31%2F%E5%B0%8F%E8%AE%B016%2F</url>
      <content type="text"><![CDATA[小记16成熟是否代表更多的沉默和更多的谎言？ Dongfangliu 过去的一年，是非常负能量的一年。我更瘦了。如果要用一个词描绘这一年，停滞。在各个方面。过去一年，我变得更加多疑，却也更加想要去相信。过去一年，我过得更加浑噩，却也更加想要去突破。心中确立一个原则，那是自我。在颓废和痛苦中不由得获得了可能会陪伴一生的韧性。自己看到的世界越来越残酷了，曾经的梦想之火暗淡，化为不灭的种子。喜悦是那一晚的关东煮，温暖刚哭过的身躯喜悦是那一路的少年郎，在寒夜中仍能嬉笑尘嚣头脑变得略微迟钝，起落涨伏之后，期待更少，理解更多这一年，有欺骗，有挣扎，有浑噩，有疲累有坚持，有陪伴，有蛋黄流沙，黑豆豆浆少了，原味更多了不再是追风的轻狂少年，她还是她，它还是它，少了偏执，学会看开，好似佛陀，却不爱人间世界上那么多恰到好处，很抱歉在下确实无缘我变了，但我还是很善良愿在孤独的路上，做无悔的自我]]></content>
    </entry>

    
  
  
</search>
